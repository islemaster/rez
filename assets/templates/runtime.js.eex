// Auto-generated by Rez v<%= Rez.version %>
// Do not modify as it will be overwritten when the game is next compiled.
<% import Rez.AST.ValueEncoder, only: [encode_attributes: 1] %>
<% alias Rez.AST.Asset %>

(function() {
  "use strict";

//-----------------------------------------------------------------------------
// Additions to JS stdlib
//-----------------------------------------------------------------------------

Object.defineProperty(Object.prototype, "copy", {
  value: function() {
    const copy = {};
    for(const property in this) {
      let value = this[property];
      if(typeof(value) == "object") {
        copy[property] = value.copy();
      } else {
        copy[property] = value;
      }
    }
    return copy;
  }
});

/*
 * Fisher-Yates Shuffle impl from: https://sebhastian.com/fisher-yates-shuffle-javascript/
 */
Object.defineProperty(Array.prototype, "fy_shuffle", {
  value: function() {
    let idx = this.length;
    while(--idx > 0) {
      const rand_idx = Math.floor(Math.random() * (idx+1));
      [this[rand_idx], this[idx]] = [this[idx], this[rand_idx]];
    }
    return this;
  }
});

Object.defineProperty(Array.prototype, "randomElement", {
  value: function() {
    return this.at(Math.floor(Math.random() * this.length));
  }
});

Object.defineProperty(Array.prototype, "randomIndex", {
  value: function() {
    return Math.floor(Math.random() * this.length);
  }
});

Object.defineProperty(String.prototype, "interpolate", {
  value: function(game) {
    return this;
  }
});

Object.defineProperty(String.prototype, "toSnakeCase", {
    value: function() {
        return this
        .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)
        .map(x => x.toLowerCase())
        .join('_');
    }
});

//-----------------------------------------------------------------------------
// Handlebars Helpers
//-----------------------------------------------------------------------------

/*
 * The `$` helper is a shortcut for outputting the value of an attribute of a
 * game object. Used as `{{$ object "attr_name"}}` it returns the attribute
 * value and is often used with the `binding:` attribute.
*/
Handlebars.registerHelper("$", function(obj, name) {
  if(typeof(obj) == "undefined" || obj == null) {
    console.log("In $ object not found");
    return "";
  } else {
    const value = obj.getAttribute(name);
    if(typeof(value) == "undefined" || value == null) {
      throw "No attribute " + name + " of object " + obj.id + " could be found!";
    } else {
      return new Handlebars.SafeString(value);
    }
  }
});

/*
 * The `r_event` handler returns an <a> tag that, when the player clicks on it,
 * sends the specified event to the enclosing card.
*/
Handlebars.registerHelper("r_event", function(title, event_name) {
  return new Handlebars.SafeString("<a href='#' class='event' data-event='" + event_name + "'>" + title + "</a>");
});

/*
 * The `r_link` handler runs the dynamic link code for the specified card &
 * action and either returns a link for taking that action, a deactivated
 * link if the action is visible but not available, or an empty string if
 * the action shouldn't be visible to the player.
 */
Handlebars.registerHelper("r_link", function(card, action) {
  let action_handler = card.attributes[action];
  if( action_handler == null ) {
    throw "No action handler for '" + action + "' on card '" + card.id + "'!";
  } else if(typeof(action_handler) != "function") {
    throw "Attribute '" + action + "' of card '" + card.id + "' is not a handler function!";
  } else {
    let link = new RezDynamicLink(card);
    action_handler(link);
    if(!link.choosen) {
      throw new Error("Choice must call one of hide/deny/allow");
    }

    if(link.display) {
      return new Handlebars.SafeString(link.markup);
    } else {
      return "";
    }
  }
});

/*
 * The `r_shift` helper transitions from one scene to another as part of the
 * narrative.
 */
Handlebars.registerHelper("r_shift", function(card, scene_id, title) {
  const new_scene = card.game.$(scene_id);
  if(new_scene == null) {
    throw "Attempt to shift to scene with id '" + scene_id + "'. Not found!";
  } else if(new_scene.game_object_type != "scene") {
    throw "Attempt to shift to scene with id '" + scene_id + "'. Is of type '" + new_scene.game_object_type + "'";
  } else {
    return new Handlebars.SafeString("<a href='javascript:void(0);' data-target='" + scene_id + "'' data-op='shift'>" + title + "</a>")
  }
});

/*
 * The `r_interlude` helper starts a new scene having prepared the way for the
 * original scene to be rejoined at the end of the new scene.
 */
Handlebars.registerHelper("r_interlude", function(card, scene_id, title) {
  const new_scene = card.game.$(scene_id);
  if(new_scene == null) {
    throw "Attempt to interlude to scene with id '" + scene_id + "'. Not found!";
  } else if(new_scene.game_object_type != "scene") {
    throw "Attempt to interlude to scene with id '" + scene_id + "'. Is of type '" + new_scene.game_object_type + "'";
  } else {
    return new Handlebars.SafeString("<a href='javascript:void(0);' data-target='" + scene_id + "'' data-op='interlude'>" + title + "</a>")
  }
});

/*
 * The `r_resume` helper returns an <a> tag that when clicked ends a scene
 * interlude and resumes the previous scene at the point it was before the
 * interlude began.
 */
Handlebars.registerHelper("r_resume", function(title) {
  return new Handlebars.SafeString("<a href='javascript:void(0);' data-target='game' data-op='resume'>" + title + "</a>");
});

/*
 * The `r_asset` helper returns a tag that embeds the file (be it image, movie,
 * or audio) referenced by the asset.
 */
Handlebars.registerHelper("r_asset", function(asset_id) {
  const game = window.game;
  const asset = game.$(asset_id);
  if(asset == null) {
    throw "Attempt to retrieve asset with id '" + asset_id + "' not found!";
  } else if(asset.game_object_type != "asset") {
    throw "Attempt to retrieve asset with id '" + asset_id + "' but found '" + asset.game_object_type + "'!";
  } else {
    return asset.tag();
  }
});

//-----------------------------------------------------------------------------
// Basic Object Prototype
//-----------------------------------------------------------------------------

/*
  Basic Object

  The basic_object is the common prototype of all in-game objects.

  It keeps a reference to the singleton Game object allowing that to be looked
  up from any other object.

  It handles getting attribute values.

  It handles execution of named event handler.
*/

let basic_object = {
  game: null,
  initialised: false,

  /*
   * Object ref lookup shortcut
  */
  $(id) {
    return this.game.getGameObject(id);
  },

  /*
   * Intialization
  */

  init() {
    if(!this.initialised) {
      console.log("Initialise " + this.id);
      this.initRefAttributes();
      this.elementInitializer();
      this.runEvent("init", {});
      this.initialised = true;
    }
  },

  initRefAttributes() {
    for(let attr_name of Object.keys(this.attributes)) {
      const value = this.getAttribute(attr_name);

      // We're looking for {ref: "attr_name"}
      if(typeof(value) == "object") {
        const ref_name = value["attr_ref"];
        if(typeof(ref_name) == "string") {
          this.initRefAttribute(attr_name, ref_name);
        }
      }
    }
  },

  elementInitializer() {
  },

  refAttrValue(ref_name) {
    const attr = this.getAttribute(ref_name);
    if(typeof(attr) == "undefined") {
      console.log("Ref '" + ref_name + "' does not point at a valid attribute");
      return null;
    } else {
      if(typeof(attr) == "function") {
        return attr(this.game, this);
      } else if(attr.constructor == RezDie) {
        return attr.roll();
      } else {
        console.log("Ref '" + ref_name + "' does not point to a valid type of attribute");
        return null;
      }
    }
  },

  initRefAttribute(attr_name, ref_name) {
    const value = this.refAttrValue(ref_name);
    if(value != null) {
      this.setAttribute(attr_name, value);
    }
  },

  /*
   * Template object copying
  */

  copyAssigningId(id) {
    if(!this.hasAttribute("template") || this.getAttribute("template") == false) {
      throw "Attempt to copy object " + this.id + " which does not have template: true";
    }
    const attributes = this.attributes.copy();
    const copy = new this.constructor(id, attributes);
    copy.runEvent("copy", {original: this});
    copy.setAttribute("template", false);
    copy.init();
    return copy;
  },

  // Need to check if there is a problem with copying copies
  // and ID auto-assignment. Shouldn't be, we should get
  // <id>_1_1, <id>_1_1_1 and so on but should be tested.
  copyWithAutoId() {
    this.auto_id_idx += 1;
    const copy_id = this.id + "_" + this.auto_id_idx;
    return this.copyAssigningId(copy_id);
  },

  /*
   * Event Handling
  */

  eventHandler(event_name) {
    return this.attributes["on_" + event_name];
  },

  willHandleEvent(event_name) {
    const handler = this.eventHandler(event_name);
    const does_handle_event = handler != null && typeof(handler) == "function";
    return does_handle_event;
  },

  runEvent(event_name, event_info) {
    console.log("Run on_" + event_name + " handler on " + this.id);
    let handler = this.eventHandler(event_name);
    if(handler != null && typeof(handler) == "function") {
      return handler(this, event_info);
    } else {
      return false;
    }
  },

  /*
   * Attribute query/get/set
  */

  getIn(path) {
    const segments = path.split(".");
    const first = segments[0];
    const rest = segments.slice(1);
    const value = this.attributes[first];

    if(null == value) {
      return null;
    } else {
      return rest.reduce((attr, segment) => {
        let next_value = attr[segment];
        if(typeof(next_value) == "undefined") {
          return null;
        } else {
          return next_value;
        }
      }, value);
    }
  },

  hasAttribute(name) {
    return !!this.attributes[name];
  },

  getAttribute(name) {
    const attr = this.attributes[name];
    return attr;
  },

  getAttributeValue(name, default_value) {
    const attr = this.getAttribute(name);
    if(typeof(attr) == "undefined") {
      if(typeof(default_value) == "undefined") {
        throw "Attempt to get value of attribute |" + name + "| which is not defined on |#" + this.id + "|";
      } else {
        return default_value;
      }
    } else if(typeof(attr) == "function") {
      return attr(this);
    } else if(attr.constructor == RezDie) {
      return attr.roll();
    } else {
      return attr;
    }
  },

  attributeHasChanged(attr_name) {
    this.changed_attributes.push(attr_name);
  },

  setAttribute(name, value) {
    if(typeof(value) == "undefined") {
      throw "Call to setAttribute with undefined value!";
    }
    this.attributes[name] = value;
    this.attributeHasChanged(name);
  },

  putIn(path, value) {
    const selectors = path.split(".");
    const first_selector = selectors[0];
    if(selectors.length == 1) {
      this.setAttribute(first_selector, value);
    } else {
      const lookup_selectors = selectors.slice(1, -1);
      let target = lookup_selectors.reduce((target, selector) => {
        return target[selector];
      }, this.getAttribute(first_selector));

      if(typeof(target) == "undefined") {
        throw "Attempt to putIn invalid path: " + path + " on " + this.id;
      } else {
        const final_selector = selectors.slice(-1);
        target[final_selector] = value;
        this.changedAttribute(first_selector);
      }
    }

    return this;
  },

  incAttribute(name, amount = 1) {
    let value = this.getAttribute(name);
    if(typeof(value) == "number") {
      this.setAttribute(name, value+amount);
    } else {
      throw "Attempt to inc/dec non-numeric attribute: " + name;
    }
  },

  decAttribute(name, amount = 1) {
    this.incAttribute(name, -amount);
  },

  /*
   * Effect Management
   */
  applyEffect(effect_id, item_id) {
    console.log("Been asked to apply effect |"+effect_id+"| from item |"+item_id+"| to |"+this.id+"|");
  },

  removeEffect(effect_id, item_id) {
    console.log("Been asked to remove effect |"+effect_id+"| from item |"+item_id+"| to |"+this.id+"|");
  },

  /*
   * Binding
  */

  addBinding(name, object) {
    const bindings = this.getAttribute("bindings") || {};
    bindings[name] = object.id;
    this.setAttribute("bindings", bindings);
  },

  /*
   * Archiving
  */

  needsArchiving() {
    return this.changed_attributes.length > 0 || this.properties_to_archive.length > 0;
  },

  archiveDataContainer() {
    return {
      id: this.id,
      type: this.game_object_type
    };
  },

  dataWithArchivedAttributes(data) {
    const obj= this;
    return this.changed_attributes.reduce(
      function(data, key) {
        data["attrs"] = data["attrs"] || {};
        data["attrs"][key] = obj.getAttribute(key)
        return data;
      },
      data
    );
  },

  dataWithArchivedProperties(data) {
    const obj = this;
    return this.properties_to_archive.reduce(
      function(data, key) {
        data["props"] = data["props"] || {};
        data["props"][key] = obj[key];
        return data;
      },
      data
    );
  },

  toJSON() {
    let data = this.archiveDataContainer();
    data = this.dataWithArchivedProperties(data);
    data = this.dataWithArchivedAttributes(data);
    return data;
  },

  loadData(data) {
    const attrs = data["attrs"];
    if(typeof(attrs) == "object") {
      for(const [k, v] of Object.entries(attrs)) {
        this.setAttribute(k, v);
      }
    }

    const props = data["props"];
    if(typeof(props) == "object") {
      for(const [k, v] of Object.entries(props)) {
        this[k] = v;
      }
    }
  }
};

Object.defineProperty(Object.prototype, "isGameObject", {
  value: function() {
      return basic_object.isPrototypeOf(this);
  }
});

//-----------------------------------------------------------------------------
// Actor
//-----------------------------------------------------------------------------

let actor_proto = {
  __proto__: basic_object,

  /*
   * Give the actor an opportunity to respond to an on_accept_item callback
   * and return a RezDecision with the result. By default items are accepted.
   */
  checkItem(inventory_id, slot_id, item_id) {
    const decision = new RezDecision("Filter Item");
    decision.default_yes();
    if(this.willHandleEvent("accept_item")) {
      this.runEvent(
        "accept_item", {
          decision: decision,
          inventory_id: inventory_id,
          item_id: item_id
        });
    }
    return decision;
  },

  elementInitializer() {
    if(this.hasAttribute("initial_location")) {
      this.move(this.getAttributeValue("initial_location"));
    }
  },

  move(location_id) {
    console.log("Moving |"+this.id+"| to |"+location_id+"|");

    if(this.hasAttribute("location")) {
      this.runEvent("leave", {location_id: this.getAttributeValue("location")});
    }

    this.setAttribute("location", location_id);
    this.runEvent("enter", {location_id: location_id});
  }
};

function RezActor(id, attributes) {
  this.id = id;
  this.auto_id_idx = 0;
  this.game_object_type = "actor";
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
};

RezActor.prototype = actor_proto;
RezActor.prototype.constructor = RezActor;

//-----------------------------------------------------------------------------
// Asset
//-----------------------------------------------------------------------------

let asset_proto = {
  __proto__: basic_object,

  tag() {
    const mime_type = this.getAttribute("detected_mime_type");
    if(mime_type.startsWith("image/")) {
      return this.imageTag();
    } else if(mime_type.startsWith("audio/")) {
      return this.audioTag();
    } else if(mime_type.startsWith("video/")) {
      return this.videoTag();
    } else {
      console.log("No tag implemented for MIME type: " + mime_type);
      return "";
    }
  },

  getDimensions() {
    const w = this.getAttribute("width");
    const h = this.getAttribute("height");

    if(w && h) {
      return "width: " + w + "; height: " + h;
    } else if(w) {
      return "width: " + w;
    } else if(h) {
      return "height: " + h;
    } else {
      return "";
    }
  },

  audioTag() {
    console.log("Audio tags not implemented");
    return "";
  },

  imageTag() {
    const style = this.getDimensions();
    return new Handlebars.SafeString("<img src='" + this.path + "' style='" + style + "' />");
  },

  videoTag() {
    console.log("Video tags not implemented");
    return "";
  }
};

function RezAsset(id, path, attributes) {
  this.id = id;
  this.game_object_type = "asset";
  this.path = path;
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezAsset.prototype = asset_proto;
RezAsset.prototype.constructor = RezAsset;

//-----------------------------------------------------------------------------
// Card
//-----------------------------------------------------------------------------

let card_proto = {
  __proto__: basic_object,
  targetType: "card",

  incRenderId() {
    this.render_id += 1;
    return this.render_id;
  },

  renderBlocks() {
    const block_ids = this.attributes["blocks"];
    if(block_ids == null) {
      return {}
    } else {
      return block_ids.reduce((blocks, block_id) => {
        const card = this.game.$(block_id);

        if( card != null ) {
          const block = card.render({"card_type": "block"});
          blocks[block_id] = block;
          return blocks;
        } else {
          throw "Attempt to render block with id '" + block_id + "'. Not found!";
        }
      }, {});
    }
  },

  customBindings() {
    if(this.hasAttribute("bindings")) {
      const custom_bindings = this.getAttribute("bindings") || {};
      const bindings = {};
      for(let binding_name of Object.keys(custom_bindings)) {
        const binding_id = custom_bindings[binding_name];
        const game_object = this.game.$(binding_id);
        if(game_object == null) {
          throw "Attempt to make binding to game object with id " + binding_id + " but no such object was found!";
        }
        bindings[binding_name] = game_object;
      }
      return bindings;
    } else {
      return {};
    }
  },

  render(bindings) {
    this.runEvent("render", {});
    const default_bindings = {card: this, render_id: this.incRenderId()};
    const block_bindings = this.renderBlocks();
    const custom_bindings = this.customBindings();
    const full_bindings = {...default_bindings, ...block_bindings, ...custom_bindings, ...bindings};
    return this.template(full_bindings);
  }
};

function RezCard(id, template, attributes) {
  this.id = id;
  this.game_object_type = "card";
  this.template = template;
  this.attributes = attributes;
  this.render_id = 0;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezCard.prototype = card_proto;
RezCard.prototype.constructor = RezCard;

//-----------------------------------------------------------------------------
// Decision
//-----------------------------------------------------------------------------

/*
 * RezDecision is an object type that can be passed to user-written filters.
 * Conceptually it's a simplified abstraction of the RezDynamicLink.
 *
 * When given a decision the caller should call either of `yes()` or
 * `no(reason)` to instruct the calling code about what to do.
 */

let decision_proto = {
  yes() {
    this.made = true;
    this.result = true;
    this.default = false;
    return this;
  },

  default_yes() {
    this.made = true;
    this.result = true;
    this.default = true;
  },

  no(reason = "none given") {
    this.made = true;
    this.result = false;
    this.reason = reason;
    this.default = false;
    return this;
  },

  default_no() {
    this.made = true;
    this.result = false;
    this.default = true;
  },

  wasMade() {
    return this.made;
  },

  usedDefault() {
    return this.default;
  },

  data() {
    return this.data;
  },

  setData(key, value) {
    this.data[key] = value;
    return this;
  },

  result() {
    return this.result;
  },

  purpose() {
    return this.purpose;
  },

  reason() {
    return this.reason;
  },
};

function RezDecision(purpose, data = {}) {
  this.purpose = purpose;
  this.made = false;
  this.decision = false;
  this.reason = "";
  this.data = data;
  this.default = false;
}

RezDecision.prototype = decision_proto;
RezDecision.prototype.constructor = RezDecision;

//-----------------------------------------------------------------------------
// Die
//-----------------------------------------------------------------------------

let die_proto = {
  between: function(min, max) {
    return Math.floor(min + Math.random() * (max - min + 1));
  },

  die() {
    return this.between(1, this.sides);
  },

  roll() {
    let sum = this.modifier;
    for(let i = 0; i<this.count; i++) {
      sum += this.die();
    }
    return sum;
  }
};

function RezDie(count, sides, modifier) {
  this.count = count;
  this.sides = sides;
  this.modifier = modifier;
}

RezDie.prototype = die_proto;
RezDie.prototype.constructor = RezDie;

//-----------------------------------------------------------------------------
// DynamicLink
//-----------------------------------------------------------------------------

let dynamic_link_proto = {
  inactive_class: "inactive",
  choosen: false,
  display: true,
  markup: "<strong>No text for dynamic link</strong>",
  card: null,

  game() {
    return this.card.game;
  },

  allow(response, target_id) {
    if(typeof(response) != "function" && target_id == null ) {
      throw new Error("Unable to build dynamic link, no target specified.");
    } else if(this.game().getTarget(target_id) == null) {
      throw new Error("Unable to build dynamic link, no card or scene '" + target_id + "' exists in the game.");
    }

    this.choosen = true;

    if(typeof(response) == "function") {
      this.markup = response();
    } else {
      this.markup = "<a href=\"javascript:void(0)\" data-target=\"" + target_id + "\">" + response + "</a>";
    }
  },

  deny(text, as_link) {
    this.choosen = true;

    if(as_link == null || as_link) {
      this.markup = "<a href=\"javascript:void(0)\" class=\""+this.inactive_class+"\">" + text + "</a>";
    } else {
      this.markup = "<span class=\"" + this.inactive_class + "\">" + text + "</span>";
    }
  },

  hide() {
    this.choosen = true;
    this.display = false;
  },

};

function RezDynamicLink(card) {
  this.card = card;
  this.game_object_type = "dynamic_link";
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezDynamicLink.prototype = dynamic_link_proto;
RezDynamicLink.prototype.constructor = RezDynamicLink;

//-----------------------------------------------------------------------------
// Effect
//-----------------------------------------------------------------------------

let effect_proto = {
  __proto__: basic_object
};

function RezEffect(id, attributes) {
  this.id = id;
  this.game_object_type = "effect";
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezEffect.prototype = effect_proto;
RezEffect.prototype.constructor = RezEffect;

//-----------------------------------------------------------------------------
// Faction
//-----------------------------------------------------------------------------

let faction_proto = {
  __proto__: basic_object
};

function RezFaction(id, attributes) {
  this.id = id;
  this.game_object_type = "faction";
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezFaction.prototype = faction_proto;
RezFaction.prototype.constructor = RezFaction;

//-----------------------------------------------------------------------------
// Game
//-----------------------------------------------------------------------------

let game_proto = {
  __proto__: basic_object,
  targetType: "game",

  $(id) {
    return this.getGameObject(id);
  },

  saveFileName(prefix) {
    const now = new Date();
    const formatter = (num) => {return String(num).padStart(2, "0");}
    const date_parts = [now.getFullYear()-2000, now.getMonth(), now.getDate(), now.getHours(), now.getMinutes(), now.getSeconds()];
    const date_mapped = date_parts.map(formatter);
    const date_joined = date_mapped.join("");
    return prefix.toSnakeCase() + "_" + date_joined + ".json";
  },

  dataWithArchivedObjects(data) {
    console.dir(this);
    console.log("Checking " + this.game_objects.size + " objects.");
    this.game_objects.forEach(function(obj, id) {
      console.log(id + " -> " + obj.needsArchiving());
      if(obj.needsArchiving()) {
        data["objs"] = data["objs"] || {};
        data["objs"][obj.id] = obj;
      }
    });
    console.log("Done");
    return data;
  },

  toJSON() {
    let data = this.archiveDataContainer();
    data = this.dataWithArchivedAttributes(data);
    data = this.dataWithArchivedProperties(data);
    data = this.dataWithArchivedObjects(data);

    return {
      "rez_archive": this.getAttribute("archive_format"),
      "data": data
    };
  },

  archive() {
    const archived = {};

    return JSON.stringify(this, function (key, value) {
      console.log("archive: ["+key+"]");

      if(key == "" || value == null) { // This is the game itself
        archived["game"] = true;
        return value;
      } else if(value.isGameObject()) { // This is a game object
        const goid = value.id;
        console.log("<- is a game object: " + goid);
        if(archived[goid]) {
          console.log("<- is already archived");
          return {
            json$safe: true,
            type: "ref",
            game_object_type: value.game_object_type,
            game_object_id: value.id
          }
        } else {
          console.log("<- archived");
          archived[goid] = true;
          return value;
        }
      } else if(typeof(value) == "function") {
        return {
          json$safe: true,
          type: "function",
          value: value.toString()
        }
      } else {
        console.log("<- value:" + value);
        return value;
      }
      return value;
    });
  },

  save() {
    this.runEvent("save", {});

    const file = new File([this.archive()], this.saveFileName(this.getAttribute("name")), {type: "application/json"});
    const link = document.createElement("a");
    link.style.display = "none";
    link.href = URL.createObjectURL(file);
    link.download = file.name;
    document.body.appendChild(link);
    link.click();
    setTimeout(() => {URL.revokeObjectURL(link.href);
                      link.parentNode.removeChild(link);
                     }, 0);
  },

  load(json) {
    const wrapper = JSON.parse(json);

    const archive_version = wrapper["rez_archive"];
    if(typeof(archive_version) == "undefined") {
      throw "JSON does not represent a Rez game archive!"
    } else if(archive_version != this.getAttribute("archive_format")) {
      throw "JSON is v" + archive_version + " which is not supported (v" + this.getAttribute("archive_format") + ")!";
    }

    const data = wrapper["data"];
    if(typeof(data) == "undefined") {
      throw "JSON does not contain data archive!";
    }

    // Load the game's attributes and properties
    this.loadData(data);

    const objs = data["objs"];
    if(typeof(objs) == "object") {
      for(const [id, obj_data] of Object.entries(objs)) {
        const obj = this.getGameObject(id);
        obj.loadData(obj_data);
      }
    }

    this.runEvent("load", {});
  },

  addGameObject(obj) {
    if(!obj.isGameObject()) {
      console.dir(obj);
      throw "Attempt to register non-game object!";
    }

    obj.game = this;
    this.game_objects.set(obj.id, obj);
    this.init_objects.push(obj);
  },

  getGameObject(id) {
    if(!this.game_objects.has(id)) {
      throw "No such ID |"+id+"| found!";
    }
    return this.game_objects.get(id);
  },

  <%# getByProto(proto) {
    return Array.from(this.game_objects.values).filter((obj) => obj.constructor.prototype == proto);
  }, %>

  getAll(target_type) {
    return Array.from(this.game_objects.values()).filter((obj) => obj.game_object_type == target_type);
  },

  getCurrentScene() {
    return this.getGameObject(this.current_scene_id);
  },

  setCurrentScene(new_scene_id) {
    if(new_scene_id == null) {
      throw "new_scene_id cannot be null!";
    }

    if(this.current_scene_id != null) {
      this.getCurrentScene().finish();
    }

    this.current_scene_id = new_scene_id;
    this.getCurrentScene().start();
  },

  getTarget(target_id) {
    if(target_id == this.id) {
      return this;
    } else {
      return this.getGameObject(target_id);
    }
  },

  container() {
    return document.getElementById(this.container_id);
  },

  render() {
    console.log("Render " + this.id);
    const curr_scene = this.getCurrentScene();
    const scene_render = curr_scene.render();
    const html = this.template({scene: scene_render});
    this.container().innerHTML = html;
    curr_scene.transformLinksToEvents();
    curr_scene.activateForms();
    curr_scene.activateInputs();
  },

  interludeWithScene(interlude_scene_id) {
    if(interlude_scene_id == null) {
      throw "interlude_scene_id cannot be null!";
    } else if(this.getCurrentScene() == null) {
      throw "cannot interlude without a current scene!";
    }

    console.log("Interlude from " + this.current_scene_id + " to " + interlude_scene_id);

    // Save the state of the current scene
    this.getCurrentScene().interrupt();
    this.scene_stack.push(this.current_scene_id);

    this.current_scene_id = interlude_scene_id;
    this.getCurrentScene().start();
  },

  resumePrevScene() {
    console.log("Resume from " + this.current_scene_id);
    if(this.scene_stack.length < 1) {
      throw "Cannot resume without a scene on the stack!";
    } else {
      // Let the interlude know we're done
      this.getCurrentScene().finish();

      // Bring the previous scene back as the current scene
      this.current_scene_id = this.scene_stack.pop();
      this.getCurrentScene().resume();
    }
  },

  start(container_id) {
    console.log("> Game.start");
    // Init every object, will also trigger on_init for any object that defines it
    this.init_objects.forEach((obj) => {obj.init()});
    this.init_objects = null;
    this.container_id = container_id;
    this.runEvent("start", {});
    this.setCurrentScene(this.getAttribute("initial_scene"));
  },

  getEnabledSystems() {
    return this.
      getAll("system").
        filter((system) => system.getAttribute("enabled") == true).
        sort((sys1, sys2) => sys1.getAttributeValue("priority") > sys2.getAttributeValue("priority"));
  },

  runTick() {
    this.getEnabledSystems().forEach(function(system) {
      system.runEvent("tick", this.wmem);
    });
  }
};

function RezGame(template, attributes) {
  this.id = "game";
  this.game_object_type = "game";
  this.attributes = attributes;
  this.scene_stack = [];
  this.current_scene_id = null;
  this.template = template;
  this.wmem = {game: this};
  this.game_objects = new Map();
  this.init_objects = [this];
  this.properties_to_archive = ["scene_stack", "current_scene_id"];
  this.changed_attributes = [];
  this.$ = this.getGameObject;
}

RezGame.prototype = game_proto;
RezGame.prototype.constructor = RezGame;

//-----------------------------------------------------------------------------
// Inventory
//-----------------------------------------------------------------------------

/*
 * A RezInventory is an object that holds RezItems in separate containers
 * designated by RezSlots.
 */

let inventory_proto = {
  __proto__: basic_object,

  slots() {
    return this.getAttributeValue("slots");
  },

  addContentHolderForSlot(slot_id) {
    this.contents[slot_id] = [];
  },

  elementInitializer() {
    for(const slot_id of this.slots()) {
      this.addContentHolderForSlot(slot_id);
    }
  },

  slotIsOccupied(slot_id) {
    return this.getContentsForSlot(slot_id).length == 0;
  },

  getContentsForSlot(slot_id) {
    return this.contents[slot_id];
  },

  appendContentToSlot(slot_id, item_id) {
    this.contents[slot_id].push(item_id);
  },

  setContentsForSlot(slot_id, contents) {
    this.contents[slot_id] = contents;
  },

  countItemsInSlot(slot_id) {
    return this.getContentsForSlot(slot_id).length;
  },

  /*
   * Determines whether the specified item is contained in any slot in this inventory.
   *
   * Either returns the slot_id that contains the item, or null.
   */
  containsItem(item_id) {
    for(const slot_id in this.contents) {
      const contents = this.getContentsForSlot(slot_id);
      if(contents.some((contained_item_id) => {
        return contained_item_id == item_id;
      })) {
        return slot_id;
      }
    }
    return null;
  },

  isOwned() {
    return this.hasAttribute("owner");
  },

  ownerId() {
    return this.getAttributeValue("owner");
  },

  owner() {
    return this.game.$(this.ownerId());
  },

  itemFitsInSlot(slot_id, item_id) {
    const capacity = this.game.$(slot_id).capacity();
    const size = this.game.$(item_id).size();
    const current_size = this.countItemsInSlot(slot_id);

    return (current_size + size) <= capacity;
  },

  slotAcceptsItem(slot_id, item_id) {
    const accepts = this.game.$(slot_id).getAttributeValue("accepts");
    const type = this.game.$(item_id).getAttributeValue("type");

    return type == accepts;
  },

  canAddItemForSlot(slot_id, item_id) {
    const decision = new RezDecision("canItemForSlot");

    if(!this.slotAcceptsItem(slot_id, item_id)) {
      decision.no("slot doesn't take this kind of item").setData("failed_on", "accepts");
    } else if(!this.itemFitsInSlot(slot_id, item_id)) {
      decision.no("does not fit").setData("failed_on", "fits");
    } else if(this.isOwned()) {
      const actor_decision = this.owner().checkItem(this.id, slot_id, item_id);
      if(actor_decision.result()) {
        decision.yes();
      } else {
        decision.no(actor_decision.reason()).setData("failed_on", "actor");
      }
    } else {
      decision.yes();
    }

    return decision;
  },

  addItemToSlot(slot_id, item_id) {
    this.appendContentToSlot(slot_id, item_id);

    this.runEvent("insert", {slot_id: slot_id, item_id: item_id});

    const slot = this.game.$(slot_id);
    slot.runEvent("insert", {inventory_id: this.id, item_id: item_id});

    this.applyEffects(item_id);
  },

  applyEffects(item_id) {
    if(!this.getAttributeValue("apply_effects", false)) {
      return;
    }

    const item = this.game.$(item_id);
    if(!item.hasAttribute("effects")) {
      return;
    }

    if(!this.hasAttribute("owner")) {
      return;
    }

    const effects = item.getAttributeValue("effects");
    const owner = this.getAttributeValue("owner");

    for(const effect_id of effects) {
      owner.applyEffect(effect_id, item_id);
    }
  },

  removeItemFromSlot(slot_id, item_id) {
    const contents = this.getContentsForSlot(slot_id);
    if(!contents.includes(item_id)) {
      throw "Attempt to remove item |"+item_id+"| from slot |"+slot_id+"| on inventory |"+this.id+"|. No such item found!";
    }

    const remaining_contents = contents.filter((id) => {return id != item_id;})
    this.setContentsForSlot(slot_id, new_contents);

    const slot = this.game.$(slot_id);
    slot.runEvent("remove", {inventory: this.id, item: item_id});
    this.runEvent("remove", {slot: slot_id, item: item_id});

    this.removeEffects(item_id);
  },

  removeEffects(item_id) {
    if(!this.getAttributeValue("apply_effects", false)) {
      return;
    }

    const item = this.game.$(item_id);
    if(!item.hasAttribute("effects")) {
      return;
    }

    if(!this.hasAttribute("owner")) {
      return;
    }

    const effects = item.getAttributeValue("effects");
    const owner = this.getAttributeValue("owner");

    for(const effect_id of effects) {
      owner.removeEffect(effect_id, item_id);
    }
  }
};

function RezInventory(id, attributes) {
  this.id = id;
  this.game_object_type = "inventory";
  this.contents = {};
  this.attributes = attributes;
  this.properties_to_archive = ["contents"];
  this.changed_attributes = [];
}

RezInventory.prototype = inventory_proto;
RezInventory.prototype.constructor = RezInventory;

//-----------------------------------------------------------------------------
// Item
//-----------------------------------------------------------------------------

let item_proto = {
  __proto__: basic_object,

  size() {
    return this.getAttributeValue("size");
  }
};

function RezItem(id, template, attributes) {
  this.id = id;
  this.template = template;
  this.auto_id_idx = 0;
  this.game_object_type = "item";
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezItem.prototype = item_proto;
RezItem.prototype.constructor = RezItem;

//-----------------------------------------------------------------------------
// Location
//-----------------------------------------------------------------------------

let location_proto = {
  __proto__: basic_object
};

function RezLocation(id, template, attributes) {
  this.id = id;
  this.game_object_type = "location";
  this.attributes = attributes;
  this.template = template;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezLocation.prototype = location_proto;
RezLocation.prototype.constructor = RezLocation;

//-----------------------------------------------------------------------------
// List
//-----------------------------------------------------------------------------

let list_proto = {
  __proto__: basic_object,
  cycles: {},
  walks: {},

  /*
   * Treat the list as a repeating cycle. Each cycle identified by an id
   * is separate.
  */
  nextForCycle(cycle_id) {
    let cycle = this.cycles[cycle_id];
    if(typeof(cycle) == "undefined") {
      cycle = 0;
    }

    const value = this.values().at(cycle);

    cycle += 1;
    this.cycles[cycle_id] = cycle;

    return value;
  },

  /*
   *  Returns a random element of the list with replacement.
  */
  randomElement() {
    return this.values().randomElement();
  },

  /*
   * Returns a random element of the list without replacement, i.e. no
   * item will be returned twice.
  */
  randomWalk(walk_id) {
    const walk = this.getWalk(walk_id);
    if(walk.length == 0) {
      return null;
    } else {
      return walk.shift();
    }
  },

  getWalk(walk_id) {
    let walk = this.walks[walk_id];
    if(typeof(walk) == "undefined") {
      walk = this.resetWalk(walk_id);
    }
    return walk;
  },

  resetWalk(walk_id) {
    const walk = Array.from(this.values().keys()).fy_shuffle();
    this.walks[walk_id] = walk;
    return walk;
  },

  values() {
    return this.attributes["values"];
  }
};

function RezList(id, attributes) {
  this.id = id;
  this.game_object_type = "list";
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezList.prototype = list_proto;
RezList.prototype.constructor = RezList;

//-----------------------------------------------------------------------------
// Plot
//-----------------------------------------------------------------------------

let plot_proto = {
  __proto__: basic_object,

  isActive() {
    return this.getAttribute("tick") > 0;
  },

  isComplete() {
    return this.getAttribute("tick") == this.getAttribute("ticks");
  },

  tick() {
    let curr_tick = this.getAttribute("tick");
    const max_ticks = this.getAttribute("ticks");
    if(curr_tick < max_ticks) {
      curr_tick += 1;
      this.setAttribute("tick", curr_tick);
      this.runEvent("tick", {});
    }
  }
};

function RezPlot(id, attributes) {
  this.id = id;
  this.game_object_type = "plot";
  this.status = 0;
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezPlot.prototype = plot_proto;
RezPlot.prototype.constructor = RezPlot;

//-----------------------------------------------------------------------------
// Scene
//-----------------------------------------------------------------------------

let scene_proto = {
  __proto__: basic_object,
  targetType: "scene",

  getCurrentCard() {
    return this.game.$(this.current_card_id);
  },

  getInitialCard() {
    return this.game.$(this.getAttributeValue("initial_card"));
  },

  finish() {
    this.runEvent("finish", {});
  },

  finishCurrentCard() {
    if(this.current_card_id != null) {
      const card = this.getCurrentCard();
      if(card) {
        card.runEvent("finish", {scene: this.id});
        this.runEvent("finish_card", {card: card.id});
      }
    }
  },

  startNewCard() {
    const card = this.getCurrentCard();
    if(card) {
      this.runEvent("start_card", {card: card.id});
      card.runEvent("start", {scene: this.id});
    }
  },

  playCardWithId(new_card_id) {
    console.log("Playing card: " + new_card_id);

    // Obviously if you try to set no card we should blow up
    if(new_card_id == null) {
      throw "Cannot specify null card_id!";
    }

    this.finishCurrentCard();

    // In continuous layout mode we re-display the previous rendering of
    // past cards
    const layout_mode = this.getAttribute("layout_mode");
    if(layout_mode == "continuous") {
      this.cards_played.push(this.current_render);
    }

    this.current_card_id = new_card_id;
    this.startNewCard();
    this.current_render = this.getCurrentCard().render({"card_type": "card"});
    this.game.render();
    this.getCurrentCard().runEvent("ready", {});
  },

  currentCardSelector() {
    const curr_card = this.getCurrentCard();
    return "div.card#card_" + curr_card.id + "_" + curr_card.render_id;
  },

  liveLinkSelector() {
    return [
      this.currentCardSelector() + " a[data-target]",
      this.currentCardSelector() + " a[data-event]",
      "div.block a[data-target]",
      "div.block a[data-event]"
    ].join(", ");
  },

  anchorLinks() {
    return document.querySelectorAll("a");
  },

  hotLinks() {
    return document.querySelectorAll(this.liveLinkSelector());
  },

  transformLinksToEvents() {
    const this_scene = this;

    // First deactivate all links on the page
    this.anchorLinks().forEach(function(elem) {
      elem.classList.add("inactive");
    });

    // Then selectively re-enable links in the current card
    // And links in blocks
    this.hotLinks().forEach(function(elem) {
      elem.classList.remove("inactive");
      elem.classList.add("active");

      elem.addEventListener("click", function(evt) {
        if(evt.target.dataset.event) {
          const event_name = evt.target.dataset.event;
          const event_target = evt.target.parentElement.dataset.card;
          console.log("Sending event " + event_name + " to " + event_target);
          const card = this_scene.game.$(event_target);
          if(card) {
            card.runEvent(evt.target.dataset.event, evt.target.dataset);
          } else {
            throw "Event target " + event_target + " not found!";
          }
        } else if(evt.target.dataset.target) {
          console.log("Target: " + evt.target.dataset.target);
          let target_id = evt.target.dataset.target;
          let target = this_scene.game.getTarget(target_id);
          if(typeof(target) == "undefined") {
            throw new Error("Attempt to reach undefined target: " + target_id);
          } else {
            if(target.targetType == "game") {
              if(evt.target.dataset.op == "resume") {
                target.resumePrevScene();
              } else {
                throw "Error, unexpected data-op: " + evt.target.dataset.op;
              }
            }
            if(target.targetType == "card") {
              this_scene.playCardWithId(target.id);
            } else if(target.targetType == "scene") {
              if(evt.srcElement.dataset.op == "shift") {
                this_scene.game.setCurrentScene(target.id);
              } else if(evt.srcElement.dataset.op == "interlude") {
                this_scene.game.interludeWithScene(target.id);
              } else {
                console.dir(elem);
                throw "Error, no data-op!";
              }
            }
          }
        } else {
          throw "Link without data-event or data-target was enabled!";
        }
      });
    });
  },

  formsSelector() {
    return [
      this.currentCardSelector() + " form[rez-live]",
      "div.block form[rez-live]"].join(", ");
  },

  inputsSelector() {
    return [
      this.currentCardSelector() + " input[rez-live]",
      "div.block form input[rez-live]"
    ].join(", ");
  },

  activateInputs() {
    const this_scene = this;
    const inputs_selector = this.inputsSelector();
    console.log("Inputs selector = " + inputs_selector);
    document.querySelectorAll(this.inputsSelector()).forEach(function(elem) {
      console.log("Activing inputs for " + elem.id);
      elem.addEventListener("input", function(evt) {
        const card_div = evt.target.closest(".card, .block");
        if(!card_div) {
          throw "Cannot find div for input " + elem.id + "!";
        }

        const card_id = card_div.dataset.card;
        if(!card_id) {
          throw "Cannot get card id for input " + elem.id + "!";
        }

        const card = this_scene.game.$(card_id);
        if(!card) {
          throw "Cannot locate card " + card_id + " for input " + elem.id + "!";
        }

        card.runEvent("input", {evt: evt});
        return false;
      });
    });
  },

  activateForms() {
    const this_scene = this;

    document.querySelectorAll(this.formsSelector()).forEach(function(elem) {
      elem.addEventListener("submit", function(evt) {
        evt.preventDefault();

        const form_name = evt.target.getAttribute("name");
        if(!form_name) {
          throw "Cannot get form name!";
        }

        const card_div = evt.target.closest(".card, .block");
        if(!card_div) {
          throw "Cannot find div for form: " + form_name + "!";
        }

        const card_id = card_div.dataset.card;
        if(!card_id) {
          throw "Cannot get card id of div form form: " + form_name + "!";
        }

        const card = this_scene.game.$(card_id);
        if(!card) {
          throw "Cannot locate card with id " + card_id + "!";
        }

        card.runEvent(form_name, {form: evt.target});
      });
    });
  },

  getCard(card_id) {
    const card = this.$(card_id);
    if(card.constructor != RezCard) {
      throw "Attempt to get id which does not correspond to a card";
    }
    return card;
  },

  render() {
    console.log("Rendering scene: " + this.id);
    this.runEvent("render", {});
    return this.renderLayout(this.renderCards(), this.renderBlocks());
  },

  renderLayout(card_contents, block_contents) {
    const contents = {...block_contents, ...card_contents};
    return this.layout_template(contents);
  },

  renderCards() {
    const past_content = this.cards_played.join("\n");
    const content = past_content + this.current_render;

    return {
      "content": content
    }
  },

  renderBlocks() {
    const block_ids = this.attributes["blocks"];
    if(block_ids == null) {
      return {}
    } else {
      return block_ids.reduce((blocks, block_id) => {
        const block = this.getCard(block_id);
        if( block != null ) {
          blocks[block_id] = block.render({"card_type": "block"});
          return blocks;
        } else {
          throw "Attempt to render invalid block_id: " + block_id;
        }
      }, {});
    }
  },

  reset() {
    this.cards_played = [];
    this.current_card_id = null;
    this.current_render = null;
  },

  interrupt() {
    console.log("Interrupting " + this.id);
    this.runEvent("interrupt", {});
  },

  resume() {
    console.log("Resuming " + this.id);
    this.runEvent("resume", {});

    // We need to update the screen, now we're back
    this.game.render();
  },

  start() {
    this.reset();
    this.init();
    this.playCardWithId(this.getAttribute("initial_card"))
  }
};

function RezScene(id, layout_template, attributes) {
  this.id = id;
  this.game_object_type = "scene";
  this.layout_template = layout_template;
  this.attributes = attributes;
  this.properties_to_archive = ["current_card_id", "current_render", "cards_played"];
  this.changed_attributes = [];
  this.reset();
}

RezScene.prototype = scene_proto;
RezScene.prototype.constructor = RezScene;

//-----------------------------------------------------------------------------
// Slot
//-----------------------------------------------------------------------------

let slot_proto = {
  __proto__: basic_object,

  capacity() {
    return this.getAttributeValue("capacity");
  },
};

function RezSlot(id, attributes) {
  this.id = id;
  this.game_object_type = "slot";
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezSlot.prototype = slot_proto;
RezSlot.prototype.constructor = RezSlot;

//-----------------------------------------------------------------------------
// System
//-----------------------------------------------------------------------------

let system_proto = {
  __proto__: basic_object
};

function RezSystem(id, attributes) {
  this.id = id;
  this.game_object_type = "system";
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezSystem.prototype = system_proto;
RezSystem.prototype.constructor = RezSystem;

//-----------------------------------------------------------------------------
// Task
//-----------------------------------------------------------------------------

let task_proto = {
  __proto__: basic_object,

  option(name) {
    return this.options[name];
  },

  firstChild() {
      return this.children[0];
  },

  secondChild() {
    return this.children[1];
  },

  getChild(idx) {
    return this.children[idx];
  },

  children() {
    return this.children;
  },

  childCount() {
    return this.children.length;
  },

  execute(wmem) {
    // By definition this is a function of two attributes
    // (task, wmem)
    const handler = this.attributes["execute"];
    return handler(this, wmem);
  },

  instantiate(options, children = []) {
    const task = this.copyWithAutoId();
    task.options = options;
    task.children = children;
    return task;
  }
};

function RezTask(id, attributes) {
  this.id = id;
  this.game_object_type = "task";
  this.auto_id_idx = 0;
  this.options = {};
  this.children = [];
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezTask.prototype = task_proto;
RezTask.prototype.constructor = RezTask;

//-----------------------------------------------------------------------------
// Zone
//-----------------------------------------------------------------------------

let zone_proto = {
  __proto__: basic_object,

  addLocation(location) {
    location.zone = this;
    this.locations[location.id] = location;
  },

  getLocation(location_id) {
    return this.locations[location_id];
  }
};

function RezZone(id, attributes) {
  this.id = id;
  this.game_object_type = "zone";
  this.locations = {};
  this.attributes = attributes;
  this.properties_to_archive = [];
  this.changed_attributes = [];
}

RezZone.prototype = zone_proto;
RezZone.prototype.constructor = RezZone;

/******************************************************************************
  Initialize game objects
******************************************************************************/

const game = new RezGame(
  Handlebars.template(<%= @game.template %>),
  <%= encode_attributes(@game.attributes) %>
);

basic_object.game = game;

/* Encode tasks that will be referred to in behaviours attributes */
<%= for {id, task} <- @game.tasks do %>
game.addGameObject(
  new RezTask(
    "<%= id %>",
    <%= encode_attributes(task.attributes) %>
  )
);
<% end %>

/* Encode game objects */
<%= for {id, actor} <- @game.actors do %>
game.addGameObject(
  new RezActor(
    "<%= id %>",
    <%= encode_attributes(actor.attributes) %>
  )
);
<% end %>

<%= for {id, asset} <- @game.assets do %>
game.addGameObject(
  new RezAsset(
    "<%= id %>",
    "<%= Asset.asset_path(asset) %>",
    <%= encode_attributes(asset.attributes) %>
  )
);
<% end %>

<%= for {id, card} <- @game.cards do %>
game.addGameObject(
  new RezCard(
    "<%= id %>",
    Handlebars.template(<%= card.template %>),
    <%= encode_attributes(card.attributes) %>
  )
);
<% end %>

<%= for {id, effect} <- @game.effects do %>
game.addGameObject(
  new RezEffect(
    "<%= id %>",
    <%= encode_attributes(effect.attributes) %>
  )
);
<% end %>

<%= for {id, faction} <- @game.factions do %>
game.addGameObject(
  new RezFaction(
    "<%= id %>",
    <%= encode_attributes(faction.attributes) %>
  )
);
<% end %>

<%= for {id, inventory} <- @game.inventories do %>
game.addGameObject(
  new RezInventory(
      "<%= id %>",
      <%= encode_attributes(inventory.attributes) %>
    )
);
<% end %>

<%= for {id, item} <- @game.items do %>
game.addGameObject(
  new RezItem(
    "<%= id %>",
    <%= if is_nil(item.template) do %>
      null
    <% else %>
      Handlebars.template(<%= item.template %>)
    <% end %>,
    <%= encode_attributes(item.attributes) %>
  )
);
<% end %>

<%= for {id, list} <- @game.lists do %>
game.addGameObject(
  new RezList(
    "<%= id %>",
    <%= encode_attributes(list.attributes) %>
  )
);
<% end %>

<%= for {id, plot} <- @game.plots do %>
game.addGameObject(
  new RezPlot(
    "<%= id %>",
    <%= encode_attributes(plot.attributes) %>
  )
);
<% end %>

<%= for {id, scene} <- @game.scenes do %>
game.addGameObject(
  new RezScene(
    "<%= id %>",
    Handlebars.template(<%= scene.layout_template %>),
    <%= encode_attributes(scene.attributes) %>
  )
);
<% end %>

<%= for {slot_id, slot} <- @game.slots do %>
game.addGameObject(
  new RezSlot(
    "<%= slot_id %>",
    <%= encode_attributes(slot.attributes) %>
  )
);
<% end %>

<%= for {id, system} <- @game.systems do %>
game.addGameObject(
  new RezSystem(
    "<%= id %>",
    <%= encode_attributes(system.attributes) %>
  )
);
<% end %>

<%= for {id, topic} <- @game.topics do %>
game.addGameObject(
  new RezTopic(
    "<%= id %>",
    <%= encode_attributes(topic.attributes) %>
  )
);
<% end %>

<%= for {id, zone} <- @game.zones do %>
  let zone = new RezZone(
    "<%= id %>",
    <%= encode_attributes(zone.attributes) %>
  )

  game.addGameObject(zone);

  <%= for {loc_id, location} <- zone.locations do %>
    let location_<%= loc_id %> = new RezLocation(
      "<%= loc_id %>",
      <%= if is_nil(location.template) do %>
      null
      <% else %>
      Handlebars.template(<%= location.template %>)
      <% end %>,
      <%= encode_attributes(location.attributes) %>
    );

    zone.addLocation(location_<%= loc_id %>);
    game.addGameObject(location_<%= loc_id %>);
  <% end %>
<% end %>

window.$ = (id) => game.$(id);
window.$game = game;

})();
