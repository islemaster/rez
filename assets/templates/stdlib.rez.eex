%% <% _ = assigns %>
%% Autogenerated with Rez v<%= Rez.version() %>
%% ** Do not modify as local changes will be overwritten every time the game is compiled **

@scene default_load_game begin
    initial_card: #default_load_game_form
    layout: """
    {{{content}}}
    """
  end

@card default_load_game_form begin
  content: """
  <form name="load_form">
    <input type="file" name="data"/>
    <input type="submit"/>
  </form>
  """

  on_load_form: (card, data) => {
    console.log("In the load form handler!");
    const form = data.form;
    const file_input = form.querySelector("input[type=file]");
    const [file] = file_input.files;
    const reader = new FileReader();
    reader.addEventListener("load", function() {
      window.game.load(reader.result);
      window.game.render();
    });
    reader.readAsText(file);
  }
end

@system actor_behaviours begin
  enabled: true
  priority: 10
  on_tick: (event) => {
    console.log("Running actor_behaviours system");
    const game = event.game;
    const actors = game.getAll("actor").filter((actor) => {return actor.hasAttribute("behaviours")});
    const wmem = {};
    actors.forEach((actor) => {
      const btree = actor.getAttributeValue("behaviours");
      btree.execute(wmem);
    });
  }
end

%% Standard behaviours
%% By convention we give behaviours an UPPER CASE id to make it less likely
%% they will clash with author generated id's. The core of these behaviours
%% model the 'generic' behaviours implemented in the Crysis engine:
%% https://docs.cryengine.com/display/CEPROG/Modular+Behavior+Tree+Nodes
%% See the Behaviour Tree part of the user guide for more information.

@behaviour SELECT begin
  %% The SELECT behaviour executes it's children in turn until one of them
  %% succeeds, then SELECT succeeds. If no child succeeeds then SELECT fails.

  template: true
  options: []
  min_children: 2

  execute: (behaviour, wmem) => {
    let result = {success: true, wmem: wmem};
    for(const child of behaviour.children) {
      result = child.execute(result.wmem);
      if(result.success) {
        break;
      }
    }
    return result;
  }
end

@behaviour SELECT_P begin
  %% The SELECT_P behaviour is similar to SELECT except that before ticking any
  %% child it does a probability check using the "p" option. If the check passes
  %% it ticks the child, otherwise it moves on to the next child. If a child
  %% succeeds SELECT_P succeeds. If no child succeeds, SELECT_P fails.

  template: true
  options: [:p]
  min_children: 2

  check_p: (behaviour, p) => {
    if(typeof(p) != "integer" || p < 0) {
      behaviour.error = "p must be zero or a positive integer";
      return false;
    } else {
      return true;
    }
  }

  execute: (behaviour, wmem) => {
    const p = behaviour.config("p");
    const die = new RezDie(1, 100, 0);
    let result = {success: false, id: behaviour.id, wmem};
    for(const child of behaviour.children) {
      if(die.roll() < p) {
        result = child.execute(result.wmem);
        if(result.success) {
          break;
        }
      }
    }
    return result;
  }
end

@behaviour SEQUENCE begin
  %% The SEQUENCE behaviour executes its children in turn. If they all succeed
  %% then the SEQUENCE succeeds. If a child fails the SEQUENCE fails and does
  %% not execute any further children.

  template: true
  options: []
  min_children: 2

  execute: (behaviour, wmem) => {
    let result = {success: true, wmem: wmem};
    for(const child of behaviour.children) {
      result = child.tick(result.wmem);
      if(result.success) {
        break;
      }
    }
  }
end

@behaviour LOOP begin
  %% The LOOP behaviour takes one child and executes it 'count' times. If it
  %% succeeds on every repetition the LOOP succeeds. If the child ever fails
  %% the LOOP fails.

  template: true
  options: [:count]
  min_children: 1
  max_children: 1

  execute: (behaviour, wmem) => {
    const count = behaviour.option("count");
    let result = {success: false, wmem: wmem};
    for(const i=0; i<count; i++) {
      result = child.execute(result.wmem);
      if(!result.success) {
        return result;
      }
    }

    return result;
  }
end

@behaviour LOOP_UNTIL begin
  %% The LOOP_UNTIL behaviour takes one child and executes it until it
  %% succeeds. The 'attempts' option specifies how many times it will
  %% executed. If the child ever succeeds, LOOP_UNTIL succeeds. If the
  %% child doesn't succeed in the number of attempts then LOOP_UNTIL fails.

  template: true
  options: [:attempts]
  min_children: 1
  max_children: 1

  execute: (behaviour, wmem) => {
    let result = {success: false, wmem: wmem};
    for(let i=0; i<this.count(); i++) {
      result = this.firstChild().tick(result.db);
      if(tick_succeeded(result)) {
        break;
      }
    }

    return result;
  }
end

@behaviour MAYBE begin
  %% The MAYBE behaviour takes one child and based on the option "p" determines
  %% whether to execute it or not. If it executes the child then MAYBE succeeds
  %% if the child succeeds or fails if the child fails. If it doesn't execute
  %% the child then MAYBE fails.

  template: true
  options: [:p]
  min_children: 1
  max_children: 1

  execute: (behaviour, wmem) => {
    const p = behaviour.option("p");
    const die = new RezDie(1, 100, 0);

    if(die.roll() < p) {
      return behaviour.firstChild().execute(wmem);
    } else {
      return {success: false, id: behaviour.id, error: "Didn't execute"};
    }
  }
end

@behaviour EITHER begin
  %% The EITHER behaviour takes two children and based on the probability
  %% option "p" determines whether to execute the first or second child.
  %% Having decided which child to execute EITHER succeeds or fails based
  %% on whether the selected child succeeds or fails.

  template: true
  options: [:p]
  min_children: 2
  max_children: 2

  execute: (behaviour, wmem) => {
    const p = behaviour.option("p");
    const die = new RezDie(1, 100, 0);
    const roll = die.roll();

    if(roll < p) {
      return behaviour.firstChild().execute(wmem);
    } else {
      return behaviour.secondChild().execute(wmem);
    }
  }
end

@behaviour RANDOM_CHOICE begin
  %% The RANDOM_CHOICE behaviour takes two or more children. When RANDOM_CHOICE
  %% executes it selects a child at random and executes it. If that child
  %% succeeds then RANDOM_CHOICE succeeds, otherwise it fails.

  template: true
  options: []
  min_children: 2

  execute: (behaviour, wmem) => {
    const die = new RezDie(1, behaviour.childCount(), 0);
    const child = behaviour.getChild(die.roll());
    return child.execute(wmem);
  }
end

@behaviour RANDOM_EACH begin
  %% The RANDOM_EACH behaviour takes two or more children. When RANDOM_EACH
  %% executes it selects a child, without replacement, and executes it. If
  %% the selected child succeeds then RANDOM_EACH succeeds, otherwise it
  %% fails. Without replacement means that no child can be selected twice
  %% until all children have been selected at least once.

  template: true
  options: []
  min_children: 2

  execute: (behaviour, wmem) => {
    let child_walk = wmem[this];

    if(typeof(child_walk) == "undefined" || child_walk.length == 0) {
      child_walk = Array.from(Array(behaviour.childCount()).keys()).shuffle();
    }

    const child = child_walk.shift();
    wmem[this] = child_walk;

    return child.execute(wmem);
  }
end

@behaviour ALWAYS begin
  %% The ALWAYS behaviour takes one child and executes it, ALWAYS succeeds
  %% regardless of whether the child succeeds.

  template: true
  options: []
  min_children: 1
  max_children: 1

  execute: (behaviour, wmem) => {
    const result = this.firstChild().execute(wmem);
    result.success = true;
    return result;
  }
end

@behaviour NEVER begin
  %% The NEVER behaviour takes one child and executes it, NEVER fails regardless
  %% of whether the child fails.

  template: true
  options: []
  min_children: 1
  max_children: 1

  execute: (behaviour, wmem) => {
    const result = behaviour.firstChild().execute(wmem);
    result.success = false;
    return result;
  }
end

@behaviour INVERT begin
  %% The INVERT behaviour takes one child and executes it. If the child succeeds
  %% then INVERT will fail. If the child fails then INVERT will succeed.

  template: true
  options: []
  min_children: 1
  max_children: 1

  execute: (behaviour, wmem) => {
    const result = this.firstChild().execute(wmem);
    if(result.success) {
      result.success = false;
      result.error = "Inversion";
      result.id = behaviour.id;
    } else {
      result.success = true;
    }
  }
end

@behaviour FAIL begin
  %% The FAIL behaviour automatically fails.

  template: true
  options: []
  max_children: 0

  execute: (behaviour, wmem) => {
    return {success: false, wmem: wmem};
  }
end

@behaviour SUCCEED begin
  %% The SUCCEED behaviour automatically succeeds.

  template: true
  options: []
  max_children: 0

  execute: (behaviour, wmem) => {
    return {success: true, wmem: wmem};
  }
end
